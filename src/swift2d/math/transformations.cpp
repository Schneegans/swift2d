////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// This file is part of Swift2D.                                              //
//                                                                            //
// Copyright: (c) 2011-2014 Simon Schneegans & Felix Lauer                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// includes  -------------------------------------------------------------------
#define M_PI 3.14159265358979323846

#include <swift2d/math/transformations.hpp>

#include <iostream>
#include <sstream>

namespace swift {
namespace math {

////////////////////////////////////////////////////////////////////////////////

mat3 make_transformation(vec2 const& pos, float rot, float scale) {
  return make_transformation(pos, rot, vec2(scale, scale));
}

////////////////////////////////////////////////////////////////////////////////

mat3 make_transformation(vec2 const& pos, float rot, vec2 const& scale) {
  return make_translation(pos) * make_rotation(rot) * make_scale(scale);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

mat3 make_scale (vec2 const& scale) {
  return make_scale(scale.x(), scale.y());
}

////////////////////////////////////////////////////////////////////////////////

mat3 make_scale (float scale) {
  return make_scale(scale, scale);
}

////////////////////////////////////////////////////////////////////////////////

mat3 make_scale (float x, float y) {
  return mat3(x, 0, 0,
              0, y, 0,
              0, 0, 1);
}

////////////////////////////////////////////////////////////////////////////////

mat3 make_rotation (float angle) {
  return mat3(std::cos(angle), -std::sin(angle), 0,
              std::sin(angle),  std::cos(angle), 0,
              0,                0,               1);
}

////////////////////////////////////////////////////////////////////////////////

mat3 make_translation (vec2 const& delta) {
  return make_translation(delta.x(), delta.y());
}

////////////////////////////////////////////////////////////////////////////////

mat3 make_translation (float x, float y) {
  return mat3(1, 0, x,
              0, 1, y,
              0, 0, 1);
}

////////////////////////////////////////////////////////////////////////////////

mat3 make_inversed (mat3 const& mat) {
  return oglplus::Inverse(mat);
}

////////////////////////////////////////////////////////////////////////////////

mat3 make_transposed (mat3 const& mat) {
  return mat3(mat.At(0,0), mat.At(1,0), mat.At(2,0),
              mat.At(0,1), mat.At(1,1), mat.At(2,1),
              mat.At(0,2), mat.At(1,2), mat.At(2,2));
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void scale (mat3& mat, vec2 const& scale) {
  mat = mat * make_scale(scale);
}

////////////////////////////////////////////////////////////////////////////////

void scale (mat3& mat, float scale) {
  mat = mat * make_scale(scale);
}

////////////////////////////////////////////////////////////////////////////////

void scale (mat3& mat, float x, float y) {
  mat = mat * make_scale(x, y);
}

////////////////////////////////////////////////////////////////////////////////

void rotate (mat3& mat, float angle) {
  mat = mat * make_rotation(angle);
}

////////////////////////////////////////////////////////////////////////////////

void translate (mat3& mat, vec2 const& delta) {
  mat = mat * make_translation(delta);
}

////////////////////////////////////////////////////////////////////////////////

void translate (mat3& mat, float x, float y) {
  mat = mat * make_translation(x, y);
}

////////////////////////////////////////////////////////////////////////////////

void inverse (mat3& mat) {
  mat = make_inversed(mat);
}

////////////////////////////////////////////////////////////////////////////////

void transpose (mat3& mat) {
  mat = make_transposed(mat);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

mat3 scaled (mat3 const& mat, vec2 const& scale) {
  return mat * make_scale(scale);
}

////////////////////////////////////////////////////////////////////////////////

mat3 scaled (mat3 const& mat, float scale) {
  return mat * make_scale(scale);
}

////////////////////////////////////////////////////////////////////////////////

mat3 scaled (mat3 const& mat, float x, float y) {
  return mat * make_scale(x, y);
}

////////////////////////////////////////////////////////////////////////////////

mat3 rotated (mat3 const& mat, float angle) {
  return mat * make_rotation(angle);
}

////////////////////////////////////////////////////////////////////////////////

mat3 translated (mat3 const& mat, vec2 const& delta) {
  return mat * make_translation(delta);
}

////////////////////////////////////////////////////////////////////////////////

mat3 translated (mat3 const& mat, float x, float y) {
  return mat * make_translation(x, y);
}

////////////////////////////////////////////////////////////////////////////////

mat3 inversed (mat3 const& mat) {
  return make_inversed(mat);
}

////////////////////////////////////////////////////////////////////////////////

mat3 transposed (mat3 const& mat) {
  return make_transposed(mat);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

vec2 get_translation(mat3 const& mat) {
  return vec2(mat.At(0, 2), mat.At(1, 2));
}

////////////////////////////////////////////////////////////////////////////////

vec2 get_scale(mat3 const& mat) {
  return vec2((vec2(mat.At(0, 0), mat.At(0, 1))).Length(),
              (vec2(mat.At(1, 0), mat.At(1, 1))).Length());
}

////////////////////////////////////////////////////////////////////////////////

float get_rotation(mat3 const& mat) {
  float tmp(std::atan2(mat.At(0, 0), mat.At(0, 1)) - M_PI/2);
  return tmp >= 0 ? tmp : tmp + 2*M_PI;
}

////////////////////////////////////////////////////////////////////////////////

vec2 get_direction(mat3 const& mat) {
  return (mat * vec3(1, 0, 0)).xy();
}

////////////////////////////////////////////////////////////////////////////////

vec2 get_direction(float rotation) {
  return vec2(std::cos(rotation), std::sin(rotation));
}

////////////////////////////////////////////////////////////////////////////////

float get_rotation(vec2 const& vec) {
  float tmp(std::atan2(vec.y(), vec.x()));
  return tmp >= 0 ? tmp : tmp + 2*M_PI;
}

////////////////////////////////////////////////////////////////////////////////

float get_length(vec2 const& vec) {
  return vec.Length();
}

////////////////////////////////////////////////////////////////////////////////

float get_length_squared(vec2 const& vec) {
  return vec.x()*vec.x() + vec.y()*vec.y();
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void set_translation(mat3& mat, vec2 const& val) {
  set_translation(mat, val.x(), val.y());
}

////////////////////////////////////////////////////////////////////////////////

void set_translation(mat3& mat, float x, float y) {
  mat.Set(0, 2, x);
  mat.Set(1, 2, y);
}

////////////////////////////////////////////////////////////////////////////////

void set_scale(mat3& mat, vec2 const& val) {
  scale(mat, val-get_scale(mat));
}

////////////////////////////////////////////////////////////////////////////////

void set_rotation(mat3& mat, float val) {
  rotate(mat, val-get_rotation(mat));
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

vec3 normalized(vec3 const& vec) {
  return vec / vec.Length();
}

////////////////////////////////////////////////////////////////////////////////

vec2 normalized(vec2 const& vec) {
  return vec / vec.Length();
}

////////////////////////////////////////////////////////////////////////////////

void normalize(vec3& vec) {
  vec = normalized(vec);
}

////////////////////////////////////////////////////////////////////////////////

void normalize(vec2& vec) {
  vec = normalized(vec);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

float dot(vec2 const& a, vec2 const& b) {
  return ogl::Dot(a, b);
}

float dot(vec3 const& a, vec3 const& b) {
  return ogl::Dot(a, b);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

mat4 to_3D(mat3 const& mat) {
  mat4 result;

  for (int i(0); i<3; ++i) {
    for (int j(0); j<3; ++j) {
      result.Set(i, j==2 && i!=2 ? 3:j, mat.At(i, j));
    }
  }

  return result;
}

}
}
